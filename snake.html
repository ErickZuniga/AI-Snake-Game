<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game v1.11</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            border: 1px solid black;
        }
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #startMenu {
            text-align: center;
            margin-bottom: 20px;
        }
        button {
            font-size: 18px;
            margin: 5px;
            padding: 10px 20px;
        }
        #version {
            position: absolute;
            bottom: -30px;
            right: 0;
            font-size: 14px;
            color: #666;
        }
        #musicControls {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <h2>Snake Game</h2>
        <p>Select Difficulty:</p>
        <button onclick="startGame('easy')">Easy</button>
        <button onclick="startGame('medium')">Medium</button>
        <button onclick="startGame('hard')">Hard</button>
    </div>
    <div id="score">Score: 0</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="version">v1.11</div>
    </div>
    <div id="musicControls">
        <button onclick="toggleMusic()">Toggle Music</button>
        <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="0.5" onchange="adjustVolume()">
    </div>
    <audio id="eatSound" src="392883__clif_creates__hard-candy-bone-crunch.wav" preload="auto"></audio>
    <audio id="gameOverSound" src="415079__harrietniamh__video-game-death-sound-effect.wav" preload="auto"></audio>
    <audio id="backgroundMusic" src="670772__ustym_petrovych__8-bit-tune-short-sketch-adventure.wav" loop preload="auto"></audio>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startMenu = document.getElementById('startMenu');
        const gameContainer = document.getElementById('gameContainer');
        const eatSound = document.getElementById('eatSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const volumeControl = document.getElementById('volumeControl');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let snake = [{x: 10, y: 10}];
        let food = {x: 15, y: 15};
        let dx = 0;
        let dy = 0;
        let score = 0;
        let gameSpeed;
        let gameLoop;

        document.addEventListener('keydown', changeDirection);

        function startGame(difficulty) {
            startMenu.style.display = 'none';
            gameContainer.style.display = 'block';
            scoreElement.style.display = 'block';

            switch(difficulty) {
                case 'easy':
                    gameSpeed = 120;
                    break;
                case 'medium':
                    gameSpeed = 100;
                    break;
                case 'hard':
                    gameSpeed = 80;
                    break;
            }

            resetGame();
            gameLoop = setInterval(drawGame, gameSpeed);
            backgroundMusic.play();
        }

        function resetGame() {
            snake = [{x: 10, y: 10}];
            generateFood();
            dx = 0;
            dy = 0;
            score = 0;
            updateScore();
        }

        function changeDirection(event) {
            const LEFT_KEY = 37;
            const RIGHT_KEY = 39;
            const UP_KEY = 38;
            const DOWN_KEY = 40;

            const keyPressed = event.keyCode;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if (keyPressed === LEFT_KEY && !goingRight) {
                dx = -1;
                dy = 0;
            }
            if (keyPressed === UP_KEY && !goingDown) {
                dx = 0;
                dy = -1;
            }
            if (keyPressed === RIGHT_KEY && !goingLeft) {
                dx = 1;
                dy = 0;
            }
            if (keyPressed === DOWN_KEY && !goingUp) {
                dx = 0;
                dy = 1;
            }
        }

        function drawGame() {
            clearCanvas();
            moveSnake();
            drawFood();
            drawSnake();
            checkCollision();
            updateScore();
        }

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function moveSnake() {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            if (head.x < 0) head.x = tileCount - 1;
            if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1;
            if (head.y >= tileCount) head.y = 0;

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                eatSound.play();
                generateFood();
            } else {
                snake.pop();
            }
        }

        function drawFood() {
            // Draw hamster body
            ctx.fillStyle = 'burlywood';
            ctx.beginPath();
            ctx.arc((food.x + 0.5) * gridSize, (food.y + 0.5) * gridSize, gridSize / 2, 0, 2 * Math.PI);
            ctx.fill();

            // Draw ears
            ctx.fillStyle = 'peru';
            ctx.beginPath();
            ctx.arc((food.x + 0.3) * gridSize, (food.y + 0.3) * gridSize, gridSize / 5, 0, 2 * Math.PI);
            ctx.arc((food.x + 0.7) * gridSize, (food.y + 0.3) * gridSize, gridSize / 5, 0, 2 * Math.PI);
            ctx.fill();

            // Draw eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc((food.x + 0.35) * gridSize, (food.y + 0.5) * gridSize, gridSize / 10, 0, 2 * Math.PI);
            ctx.arc((food.x + 0.65) * gridSize, (food.y + 0.5) * gridSize, gridSize / 10, 0, 2 * Math.PI);
            ctx.fill();

            // Draw nose
            ctx.fillStyle = 'pink';
            ctx.beginPath();
            ctx.arc((food.x + 0.5) * gridSize, (food.y + 0.6) * gridSize, gridSize / 10, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawSnake() {
            snake.forEach((segment, index) => {
                if (index === 0) {
                    drawSnakeHead(segment);
                } else if (index === snake.length - 1) {
                    const prevSegment = snake[index - 1];
                    drawSnakeTail(segment, prevSegment);
                } else {
                    drawSnakeBody(segment);
                }
            });
        }

        function drawSnakeHead(segment) {
            ctx.fillStyle = 'darkgreen';
            ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            
            // Eyes
            ctx.fillStyle = 'white';
            const eyeSize = gridSize / 4;
            ctx.fillRect((segment.x + 0.25) * gridSize, (segment.y + 0.25) * gridSize, eyeSize, eyeSize);
            ctx.fillRect((segment.x + 0.65) * gridSize, (segment.y + 0.25) * gridSize, eyeSize, eyeSize);
            
            // Pupils
            ctx.fillStyle = 'black';
            const pupilSize = gridSize / 8;
            ctx.fillRect((segment.x + 0.3125) * gridSize, (segment.y + 0.3125) * gridSize, pupilSize, pupilSize);
            ctx.fillRect((segment.x + 0.7125) * gridSize, (segment.y + 0.3125) * gridSize, pupilSize, pupilSize);
        }

        function drawSnakeBody(segment) {
            ctx.fillStyle = 'limegreen';
            ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
        }

        function drawSnakeTail(segment, prevSegment) {
            ctx.fillStyle = 'green';
            ctx.beginPath();

            const dx = prevSegment.x - segment.x;
            const dy = prevSegment.y - segment.y;

            // Adjust for wrap-around
            const adjustedDx = dx === 19 ? -1 : (dx === -19 ? 1 : dx);
            const adjustedDy = dy === 19 ? -1 : (dy === -19 ? 1 : dy);

            if (adjustedDx === -1) {
                // Tail pointing left (snake moving right)
                ctx.moveTo(segment.x * gridSize, segment.y * gridSize);
                ctx.lineTo(segment.x * gridSize, (segment.y + 1) * gridSize);
                ctx.lineTo((segment.x + 0.5) * gridSize, (segment.y + 0.5) * gridSize);
            } else if (adjustedDx === 1) {
                // Tail pointing right (snake moving left)
                ctx.moveTo((segment.x + 1) * gridSize, segment.y * gridSize);
                ctx.lineTo((segment.x + 1) * gridSize, (segment.y + 1) * gridSize);
                ctx.lineTo((segment.x + 0.5) * gridSize, (segment.y + 0.5) * gridSize);
            } else if (adjustedDy === -1) {
                // Tail pointing up (snake moving down)
                ctx.moveTo(segment.x * gridSize, segment.y * gridSize);
                ctx.lineTo((segment.x + 1) * gridSize, segment.y * gridSize);
                ctx.lineTo((segment.x + 0.5) * gridSize, (segment.y + 0.5) * gridSize);
            } else {
                // Tail pointing down (snake moving up)
                ctx.moveTo(segment.x * gridSize, (segment.y + 1) * gridSize);
                ctx.lineTo((segment.x + 1) * gridSize, (segment.y + 1) * gridSize);
                ctx.lineTo((segment.x + 0.5) * gridSize, (segment.y + 0.5) * gridSize);
            }

            ctx.closePath();
            ctx.fill();
        }

        function checkCollision() {
            const head = snake[0];
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                }
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            gameOverSound.play();
            setTimeout(() => {
                alert('Game Over! Your score: ' + score);
                startMenu.style.display = 'block';
                gameContainer.style.display = 'none';
                scoreElement.style.display = 'none';
            }, 200);
        }

        function generateFood() {
            food.x = Math.floor(Math.random() * tileCount);
            food.y = Math.floor(Math.random() * tileCount);
        }

        function updateScore() {
            scoreElement.textContent = 'Score: ' + score;
        }

        function toggleMusic() {
            if (backgroundMusic.paused) {
                backgroundMusic.play();
            } else {
                backgroundMusic.pause();
            }
        }

        function adjustVolume() {
            backgroundMusic.volume = volumeControl.value;
        }

        // Initially hide the game canvas and score
        gameContainer.style.display = 'none';
        scoreElement.style.display = 'none';

        // Set initial volume
        backgroundMusic.volume = volumeControl.value;
    </script>
</body>
</html>